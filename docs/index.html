<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta property="og:site_name" content="Probabilistic Differentiable Simulation">
    <meta property="og:title" content="Probabilistic Differentiable Simulation">
    <meta property="og:description"
        content="Bayesian inference of simulation parameters that leverages parallel differentiable simulators">
    <meta property="og:url" content="https://uscresl.github.io/prob-diff-sim/">
    <meta property="og:image" content="https://uscresl.github.io/prob-diff-sim/docs/img/pds_diagram.png">
    <meta property="og:image:type" content="image/jpeg">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Probabilistic Differentiable Simulation">
    <meta name="twitter:description"
        content="Bayesian inference of simulation parameters that leverages parallel differentiable simulators">
    <meta name="twitter:creator" content="@eric_heiden">
    <meta name="twitter:url" content="https://uscresl.github.io/prob-diff-sim/">
    <meta name="twitter:image:src" content="https://uscresl.github.io/prob-diff-sim/docs/img/pds_diagram.png">

    <meta name="description"
        content="Bayesian inference of simulation parameters that leverages parallel differentiable simulators">
    <meta name="author" content="Eric Heiden, Christopher E. Denniston, David Millard, Fabio Ramos, Gaurav S. Sukhatme">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous">

    <title>Probabilistic Differentiable Simulation</title>

    <style>
        div.authors p:first-of-type {
            font-size: 1.4em;
        }

        div.authors p {
            text-align: center;
        }

        div.affiliations p {
            text-align: center;
        }

        h1,
        h2 {
            margin: 1em 0;
            text-align: center;
        }

        a:link {
            text-decoration: none;
        }

        #video {
            text-align: center;
        }

        div.container {
            padding-top: 60px;
        }

        .navbar {
            padding: 0.4em 2em;
        }

        #abstract p {
            text-align: justify;
        }

        #results .label {
            margin-top: 1em;
            margin-bottom: 0.3em;
            font-weight: bold;
        }

        #results h3,
        #results h5 {
            margin-top: 2em;
        }

        .btn {
            width: 75%;
        }

        .actions .col {
            text-align: center;
        }

        p {
            text-align: justify;
        }

        table.numbers td {
            font-family: monospace !important;
            text-align: right;
            padding-right: 5%;
        }

        table.centered td,
        table.centered p {
            text-align: center !important;
        }
    </style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.css"
        integrity="sha384-zTROYFVGOfTw7JV7KUu8udsvW2fx4lWOsCEDqhBreBwlHI4ioVRtmIvEThzJHGET" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/katex.min.js"
        integrity="sha384-GxNFqL3r9uRJQhR+47eDxuPoNE7yLftQM8LcxzgS4HT73tp970WS/wV5p8UzCOmb"
        crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.18/dist/contrib/auto-render.min.js"
        integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl"
        crossorigin="anonymous"></script>

    <script>
        document.addEventListener("DOMContentLoaded", function () {
            renderMathInElement(document.body, {
                // customised options
                // • auto-render specific keys, e.g.:
                delimiters: [
                    { left: '$$', right: '$$', display: true },
                    { left: '$', right: '$', display: false },
                    { left: '\\(', right: '\\)', display: false },
                    { left: '\\[', right: '\\]', display: true }
                ],
                // • rendering keys, e.g.:
                throwOnError: false
            });
        });
    </script>
</head>

<body>
    <nav class="navbar navbar-expand-md navbar-light fixed-top bg-light">
        <a class="navbar-brand" href="#">Probabilistic Differentiable Simulation (PDS)</a>

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarToggle">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse justify-content-end position-relative" id="navbarToggle">
            <ul class="navbar-nav ml-auto">
                <li class="nav-item">
                    <a class="nav-link" href="#" target="_self">Home</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#abstract" target="_self">Abstract</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#video" target="_self">Video</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#appendix" target="_self">Appendix</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#acknowledgements" target="_self">Acknowledgements</a>
                </li>
            </ul>
        </div>
    </nav>

    <div class="container">

        <h1>Probabilistic Inference of Simulation Parameters via <br /> Parallel Differentiable Simulation</h1>

        <h2>ICRA 2022 (Under Review)</h2>

        <div class="row authors">
            <div class="col">
                <p>
                    <a href="https://eric-heiden.com">Eric Heiden</a><sup>1</sup>
                </p>
            </div>
            <div class="col">
                <p>
                    <a href="https://www.cdenniston.com">Christopher E. Denniston</a><sup>1</sup>
                </p>
            </div>
            <div class="col">
                <p>
                    <a href="https://dmillard.github.io">David Millard</a><sup>1</sup>
                </p>
            </div>
            <div class="col">
                <p>
                    <a href="https://fabioramos.github.io">Fabio Ramos</a><sup>2,3</sup>
                </p>
            </div>
            <div class="col">
                <p>
                    <a href="http://robotics.usc.edu/~gaurav/">Gaurav S. Sukhatme</a><sup>1,4</sup>
                </p>
            </div>
        </div>
        <div class="row affiliations">
            <div class="col">
                <p><sup>1</sup>University of Southern California</p>
            </div>
            <div class="col">
                <p><sup>2</sup>NVIDIA</p>
            </div>
            <div class="col">
                <p><sup>3</sup>University of Sydney</p>
            </div>
            <div class="col">
                <p><sup>4</sup>Amazon</p>
            </div>
        </div>
    </div>

    <div class="container" id="summary">
        <div class="row">
            <figure class="figure">
                <img class="figure-img img-fluid p-5" src="img/pds_diagram.png" alt="PDS" />
                <figcaption class="figure-caption">We reduce the reality gap in robotics simulators by introducing a
                    Bayesian inference approach named <em>Constrained Stein Variational Gradient Descent</em> (CSVGD).
                    Through a
                    multiple-shooting likelihood model for trajectories, and by leveraging parallel differentiable
                    simulators, CSVGD can infer complex, non-parametric posterior distributions over simulation
                    parameters for highly nonlinear systems.</figcaption>
            </figure>
            <!-- <div class="col-2">
                <video autoplay muted loop class="img-fluid">
                    <source src="apple_springs_damage.mp4" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
            </div> -->
        </div>
    </div>

    <div class="container" id="abstract">
        <div class="row">
            <h2>Abstract</h2>
            <!-- <p class="col-sm-10 fs-5"> -->
            <p>
                To accurately reproduce measurements from the real world, simulators need to have an adequate model of
                the physical system and require the parameters of the model be identified.
            </p>
            <p>
                We address the latter problem of estimating parameters through a Bayesian inference approach that
                approximates a posterior distribution over simulation parameters given real sensor measurements.
                By extending the commonly used Gaussian likelihood model for trajectories via the
                <em>multiple-shooting</em> formulation, our chosen particle-based inference algorithm <em>Stein
                    Variational Gradient
                    Descent</em> is able to identify highly nonlinear, underactuated systems. We leverage GPU code
                generation
                and differentiable simulation to evaluate the likelihood and its gradient for many particles in
                parallel.
            </p>
            <p>
                Our algorithm infers non-parametric distributions over simulation parameters more accurately than
                comparable baselines and handles constraints over parameters efficiently through gradient-based
                optimization. We evaluate estimation performance on several physical experiments. On an underactuated
                mechanism where a 7-DOF robot arm excites an object with an unknown mass configuration, we demonstrate
                how our inference technique can identify symmetries between the parameters and provide highly accurate
                predictions.
            </p>
            <!-- <div class="card col align-self-center border-0">
                <a href="">
                    <img src="paper-thumbnail.png" class="card-img-top" alt="PDS paper" />
                    <div class="card-body" align="center">
                        <h5 class="card-title">Paper on ArXiv</h5>
                    </div>
                </a>
            </div> -->
        </div>

        <!-- <div class="row actions">
            <div class="col"><a href="" target="_blank"
                    class="btn btn-primary ">Paper</a></div>
            <div class="col"><a href="#" class="btn btn-primary col">Code (coming soon!)</a></div>
            <div class="col"><a href="#" data-bs-toggle="modal" data-bs-target="#citationModal"
                    class="btn btn-primary col">Citation</a></div>
        </div> -->
    </div>

    <div class="modal fade" id="citationModal" tabindex="-1" role="dialog" aria-labelledby="citationModalTitle">
        <div class="modal-dialog modal-dialog-centered" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="citationModalLongTitle">Citation</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <pre>
@article{heiden2021pds, ... }
                    </pre>
                </div>
            </div>
        </div>
    </div>

    <div class="container" id="video">
        <h2>Video</h2>
        <div class="row justify-content-md-center">
            <div class="ratio ratio-16x9 w-75">
                <iframe src="https://www.youtube-nocookie.com/embed/QfhsWlKbfYM" title="YouTube video player"
                    frameborder="0"
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                    allowfullscreen></iframe>
            </div>
        </div>
    </div>

    <div class="container" id="appendix">
        <h2>Appendix</h2>

        <p>
            The following sections provide additional technical details that supplement our paper. Please consult our
            paper for the definition of the symbols used in the following sections.
        </p>

        $
        \gdef\paramdim{M}
        \gdef\params{\theta}
        \gdef\particles{\Theta}
        \gdef\numparticles{N}
        \gdef\statedim{D}
        \gdef\statevec{\mathbf{s}}
        \gdef\controlvec{\mathbf{u}}
        \gdef\observationdim{N}
        \gdef\observationvec{\mathbf{x}}
        \gdef\timedim{T}
        \gdef\trajectory{\mathcal{X}}
        \gdef\trajectoryset{D_\trajectory}
        \gdef\trajectorysetsub[1]{D_{\trajectory,#1}}
        \gdef\particleset{\xi}
        \gdef\simu{^{\text{sim}}}
        \gdef\real{^{\text{real}}}
        \gdef\fsim{f_{\text{sim}}}
        \gdef\fobs{f_{\text{obs}}}
        \gdef\fstep{f_{\text{step}}}
        \gdef\pobs{p_{\text{obs}}}

        \gdef\xp{\params^\prime}
        \gdef\kxx{k(\params, \xp)}
        \gdef\logprob{\log \mathcal{L}(\params)}
        \gdef\logprobp{\log \mathcal{L}(\xp)}

        \gdef\gradx{\nabla_{\params}}
        \gdef\gradxp{\nabla_{\xp}}
        \gdef\gradxxp{\nabla_{\params\xp}}

        \gdef\exparams{\bar{\params}}

        \gdef\jointpos{\mathbf{q}}
        \gdef\jointvel{\mathbf{\dot{q}}}
        \gdef\jointacc{\mathbf{\ddot{q}}}
        \gdef\jointtorque{\tau}
        \gdef\externalforce{\mathbf{f}^{\text{ext}}}
        \gdef\timestep{\Delta t}

        \gdef\pdef{p_{\text{def}}}
        \gdef\plim{p_{\text{lim}}}

        \gdef\second{\text{s}}
        \gdef\kg{\text{kg}}
        \gdef\meter{\text{m}}
        \gdef\Hz{\text{Hz}}
        $

        <h3>1 Technical Details</h3>
        <h4>1.1 Initializing the Estimators</h4>
        <p>
            For each experiment, we initialize the particles for the estimators via the deterministic Sobol sequence on
            the intervals specified through the parameter limits. Our code uses the Sobol sequence implementation
            from Burkardt [<a href="#sec:references">1</a>] which is based on a Fortran77 implementation by Fox [<a
                href="#sec:references">2</a>].
            For the MCMC methods that sample a single Markov chain, we used the center point between the parameter
            limits as initial guess.
        </p>

        <h4>1.2 Likelihood Model for Sets of Trajectories</h4>

        <p>
            In this work we assume that trajectories may have been generated by a distribution over parameters.
            In the case of a replicable experimental setup, this could be a point distribution at the only true
            parameters.
            However, when trajectories are collected from multiple robots, or with slightly different experimental
            setups between experiments}, there may be a multimodal distribution over parameters which generated the set
            of trajectories.
        </p>
        <p>
            Note, that irrespective of the choice of likelihood function we do not make any assumption about the shape
            of the posterior distribution by leveraging SVGD which is a non-parametric inference algorithm. In
            trajectory space, the Gaussian likelihood function is a common choice as it corresponds to the typical
            least-squares estimation methodology. Other likelihood distributions may be integrated with our method,
            which we leave up to future work.
        </p>
        <p>
            The likelihood which we use is a mixture of equally-weighted Gaussians centered at each reference
            trajectory $\trajectory\real$:
            $$
            \begin{equation}
            p_{sum} (\trajectoryset\real | \params) = \sum_{\trajectory\real \in \trajectoryset\real}
            p_{ss}(\trajectory\real | \params).
            \end{equation}
            $$

            If we were to consider each trajectory as an independent sample from the same trajectory distribution (the
            product), the likelihood function would be
            $$\begin{equation}
            p_{product} (\trajectoryset\real | \params) = \prod_{\trajectory\real \in \trajectoryset\real}
            p_{ss}(\trajectory\real | \params).
            \end{equation}$$

            While both equations define the likelihood for
            a combination of single-shooting likelihood functions $p_{ss}$ for a set of real trajectories
            $\trajectoryset\real$, the same combination operators (sum or product) apply to the combination of
            multiple-shooting likelihood functions $p_{ms}$ analogously.
        </p>
        <p>
            The consequence of using these likelihoods can be seen in the following figure where
            $p_{product}$ shows the resulting posterior distribution (in parameter space) when
            treating a set of trajectories as independent and taking the product of their likelihoods
            (Equation (2)), while <a href="#fig:double-pendulum-sum">Figure 1 (b)</a> shows the result of treating
            them as a sum of Gaussian likelihoods (Equation (1)).
            In <a href="#fig:double-pendulum-prod">Figure 1 (a)</a> the posterior becomes the average of the two
            distributions since that
            is the most likely position that generated both of the distinct trajectories. In contrast, the posterior
            approximated by the same algorithm (CSVGD) but using the sum of Gaussian likelihoods, successfully captures
            the multimodality in the trajectory space since most particles have aligned near the two modes of the true
            distribution in parameter space.

        </p>

        <div class="row">
            <div class="col"></div>
            <div class="col-4" id="fig:double-pendulum-prod">
                <img class="img-fluid" src="img/double_pendulum/combination_mean.png" />
                <p style="text-align: center;">(a) Product</p>
            </div>
            <div class="col-4" id="fig:double-pendulum-sum">
                <img class="img-fluid" src="img/double_pendulum/combination_logsumexp.png" />
                <p style="text-align: center;">(b) Sum</p>
            </div>
            <div class="col"></div>
        </div>

        <div class="row">
            <div class="col"></div>
            <div class="col-8">
                <p align="justify">
                    <b>Figure 1.</b> Comparison of posterior parameter distributions obtained from fitting the
                    parameters to two
                    ground-truth trajectories generated from different link lengths of a simulated double pendulum
                    (units of the axes in meters). The trajectories were 300 steps long (which corresponds to a length
                    of 3s) and contain the 2 joint positions and 2 joint velocities of the uncontrolled
                    double pendulum which starts from a zero-velocity initial configuration where the first angle is at
                    $90^\circ$ (sideways) and the other at $0^\circ$. In (a), the product of the individual
                    per-trajectory likelihoods is maximized (Equation 2). In (b), the sum
                    of the likelihoods is maximized (Equation 1).
                </p>
            </div>
            <div class="col"></div>
        </div>

        <h4 id="sec:normalization">1.3 State and Parameter Normalization</h4>

        <p>
            The parameters we are estimating are valid over only particular ranges of values. These ranges are often
            widely different - in the case of our real-world pendulum experiment, the center of mass of a link in a
            pendulum may be in the order of centimeters, while the angular velocity at the beginning of the recorded
            motion can reach values on the orders of meters per second. It is therefore important to scale the
            parameters to a common range to avoid any dimension to dominate smaller parameter ranges during the
            estimation.
        </p>
        <p>
            Similarly, the state dimensions are of different units - for example, we typically include velocities and
            positions in the recorded data over which we compute the likelihood. Therefore, we also normalize the range
            over the state dimensions. Given the state vector, respective parameter vector, $w$, we normalize each
            dimension $i$ by its statistical variance $\sigma^2$, i.e. $\frac{w_i}{\sigma_i^2}$.
        </p>

        <h4>1.4 KNN-based Approximation for KL Divergence</h4>
        <p>
            In this work, we compare a set of parameter guesses (particles) to the ground-truth parameters, or a set of
            trajectories generated by simulating trajectories from each parameter in the particle distribution to a set
            of trajectories created on a physical system.
            To compare these distributions, we use the KL divergence to determine how the two distributions differ from
            each other.
            Formally, the KL divergence is the expected value of the log likelihood ratio between two distributions, and
            is an asymmetric divergence that does not satisfy the triangle inequality.
        </p>
        <p>
            The KL divergence is easily computable in the case of discrete distributions or simple parametric
            distributions, but is not easily calculable for samples from non-parametric distributions such as those over
            trajectories.
            Instead, we use an approximation to the KL divergence which uses the relative distances between samples in a
            set to estimate the KL divergence between particle distributions.
            This method has been used to compare particle distributions over robot poses to asses the performance of
            particle filter distributions [<a href="#sec:references">3</a>].
            To estimate the KL divergence between particle distributions over trajectories $\trajectoryset^{p}$ and
            $\trajectoryset^{q}$ we adopt the formulation from [<a href="#sec:references">4</a>,<a
                href="#sec:references">3</a>]:
            $$
            \begin{equation}
            \tilde{d}_{KL} (\trajectoryset^{p} \parallel \trajectoryset^{q}) =
            \frac{\observationdim}{|\trajectoryset^p|} \sum_{i=1}^{|\trajectoryset^p|}
            \log\frac{\operatorname{KNN}^p_{k_i}(i)}{\operatorname{KNN}^q_{l_i}(i)}+ \frac{1}{|\trajectoryset^p|}
            \sum_{i=1}^{|\trajectoryset^p|} [\psi(l_i) - \psi(k_i)] +
            \log\frac{|\trajectoryset^q|}{|\trajectoryset^p|-1},
            \end{equation}
            $$
            where $\observationdim$ is the dimensionality of the trajectories, $|\trajectoryset^p|$ is the number of
            trajectories in the $\trajectoryset^{p}$ dataset, $|\trajectoryset^q|$ is the number of particles in the
            $\trajectoryset^{q}$ dataset, $\operatorname{KNN}^p_{k_i}(i)$ is the distance from trajectory $\trajectory_i
            \in \trajectoryset^{p}$ to its $k_i$-th nearest neighbor in $\trajectoryset^{q}$,
            $\operatorname{KNN}^q_{l_i}(i)$ is the distance from trajectory $\trajectory_i \in \trajectoryset^{p}$ to
            its $l_i$-th nearest neighbor in $\trajectoryset^{p} \backslash \trajectory_i$, and $\psi$ is the digamma
            function. Note that this approximation of KL divergence can also be applied to compare parameter
            distributions, as we show in the synthetic data experiment from subsection 5.1 of our main paper (cf. Figure
            4 (a) and (b) from the main paper) where the ground-truth parameter distribution is known.
        </p>
        <p>
            Throughout this work, we set $k_i$ and $l_i$ to 3 as this reduces the bias in the approximation, but does
            not require a large amount of samples from the ground-truth distribution.
        </p>

        <h3>2 Experiments</h3>
        <p>We provide further technical details and results from the experiments we present in the main paper.</p>

        <h4 id="sec:dynamics">2.1 Differentiable Simulator</h4>

        <p>
            Other than requiring a differentiable forward dynamics model which allows to simulate the system in its
            entirety following the Markov assumption, our proposed algorithm does not rely on a particular choice of
            dynamical system or simulator for which its parameters need to be estimated.
            For our experiments, we use the <em><a
                    href="https://github.com/google-research/tiny-differentiable-simulator" target="_blank">Tiny
                    Differentiable Simulator</a></em> [<a href="#sec:references">5</a>] that implements end-to-end
            differentiable contact models and the Articulated Body Algorithm (ABA) [<a href="#sec:references">6</a>] to
            compute the forward dynamics (FD) for articulated rigid-body mechanisms. Given joint positions $\jointpos$,
            velocities $\jointvel$, torques $\jointtorque$ in generalized coordinates, and external forces
            $\externalforce$, ABA calculates the joint accelerations $\jointacc$.
            We use semi-implicit Euler integration to advance the system dynamics in time for a time step $\Delta t$:
            $$
            \begin{align}
            \jointacc_{t+1} = \operatorname{ABA}(\jointpos_t, \jointvel_t, \jointtorque_t, \externalforce_t; \params),
            \qquad
            \jointvel_{t+1} = \jointvel_t + \jointacc_{t+1} \timestep, \qquad
            \jointpos_{t+1} = \jointpos_t + \jointvel_{t+1} \timestep.
            \end{align}
            $$
        </p>
        <p>
            The second-order ODE described by Equation (4) is lowered to a first-order system, with state
            $\statevec_t = \begin{bmatrix}\jointpos_t & \jointvel_t\end{bmatrix}$. Furthermore, we deal primarily with
            the discrete
            time-stepped dynamics function
            $\statevec_{t+1} = \fstep(\statevec_t, t, \params)$,
            assuming that $\timestep$ is constant. The function $\fsim(\params, \statevec_0)$ uses $\fstep$ iteratively
            to produce a trajectory of states $[\statevec]_{t=1}^T$ given an initial state $\statevec_0$ and the
            parameters $\params$. Many systems of practical interest for robotics are controlled by an external input.
            In our formulation for parameter estimation, we include controls as explicit dependencies on the time
            parameter $t$.
        </p>
        <p>
            For an articulated rigid body system, the parameters $\params$ may include (but are not limited to) the
            masses, inertial properties and geometrical properties of the bodies in the mechanism, as well as joint and
            contact friction coefficients. Given $\frac{\partial \fstep}{\partial\params}$ and
            $\frac{\partial\fstep}{\partial\statevec}$, gradients of simulation parameters with respect to the state
            trajectories can be computed directly through the chain rule, or via the adjoint sensitivity
            method [<a href="#sec:references">7</a>].
        </p>


        <h4 id="sec:ibm-pendulum">2.2 Identify Real-world Double Pendulum</h4>
        <p>
            We set up the double pendulum estimation experiment with the 11 parameters shown in
            <a href="#tab:params-ibm-pendulum">Table 1</a> to be estimated. The state space consists of the two
            positions and
            velocities of both joints: $\statevec = \begin{bmatrix}\mathbf{q}_{0:1} &
            \mathbf{\dot{q}}_{0:1}\end{bmatrix}$. The dataset of
            trajectories contains image sequences (see time lapse of an excerpt from a trajectory in
            <a href="#fig:ibm-pendulum-timelapse">Figure 2</a>) and annotated pixel coordinates of the three vertices in
            the double
            pendulum, from which we extracted joint positions and velocities (via finite differencing given the known
            recording frequency of 400Hz).

        </p>

        <div class="row">
            <div class="col-md-8" id="tab:params-ibm-pendulum">
                <table class="table">
                    <thead>
                        <tr>
                            <th scope="col">Link</th>
                            <th scope="col">Parameter</th>
                            <th scope="col" colspan="2" style="text-align:center">Minimum</th>
                            <th scope="col" colspan="2" style="text-align:center">Maximum</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <th rowspan="5">Link 1</th>
                            <th>Mass</th>
                            <td align="right">0.05 </td>
                            <td> $\kg$ </td>
                            <td align="right"> 0.5 </td>
                            <td> $\kg$ </td>
                        </tr>
                        <tr>
                            <th> $I_{xx}$ </th>
                            <td align="right"> 0.002 </td>
                            <td> $\kg\cdot\meter^2$ </td>
                            <td align="right"> 1.0 </td>
                            <td> $\kg\cdot\meter^2$</td>
                        </tr>
                        <tr>
                            <th> COM $x$ </th>
                            <td align="right"> -0.2 </td>
                            <td> $\meter$ </td>
                            <td align="right"> 0.2 </td>
                            <td> $\meter$ </td>
                        </tr>
                        <tr>
                            <th> COM $y$ </th>
                            <td align="right"> -0.2 </td>
                            <td> $\meter$ </td>
                            <td align="right"> 0.2 </td>
                            <td> $\meter$ </td>
                        </tr>
                        <tr>
                            <th> Joint friction </th>
                            <td align="right"> 0.0 </td>
                            <td> </td>
                            <td align="right"> 0.5 </td>
                            <td> </td>
                        </tr>
                        <tr>
                            <th rowspan="6">Link 2
                            <th>Length </th>
                            <td align="right"> 0.08 </td>
                            <td> $\meter$ </td>
                            <td align="right"> 0.3 </td>
                            <td> $\meter$ </td>
                        </tr>
                        <tr>
                            <th> Mass </th>
                            <td align="right"> 0.05 </td>
                            <td> $\kg$ </td>
                            <td align="right"> 0.5 </td>
                            <td> $\kg$ </td>
                        </tr>
                        <tr>
                            <th> $I_{xx}$ </th>
                            <td align="right"> 0.002 </td>
                            <td> $\kg\cdot\meter^2$ </td>
                            <td align="right"> 1.0 </td>
                            <td> $\kg\cdot\meter^2$ </td>
                        </tr>
                        <tr>
                            <th> COM $x$ </th>
                            <td align="right"> -0.2 </td>
                            <td> $\meter$ </td>
                            <td align="right"> 0.2 </td>
                            <td> $\meter$ </td>
                        </tr>
                        <tr>
                            <th> COM $y$ </th>
                            <td align="right"> -0.2 </td>
                            <td> $\meter$ </td>
                            <td align="right"> 0.2 </td>
                            <td> $\meter$ </td>
                        </tr>
                        <tr>
                            <th> Joint friction </th>
                            <td align="right"> 0.0 </td>
                            <td> </td>
                            <td align="right"> 0.5 </td>
                            <td> </td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div class="col-md-4" id="fig:ibm-pendulum-timelapse">
                <img src="img/ibm_pendulum/ibm-pendulum-timelapse.png" alt="IBM Pendulum" class="img-fluid" />
            </div>
        </div>
        <div class="row">
            <div class="col-md-8">
                <p>
                    <b>Table 1.</b> Parameters to be estimated. $I$ refers to the $3\times3$ inertia matrix, COM stands
                    for center of mass.
                </p>
            </div>
            <div class="col-md-4">
                <p><b>Figure 2.</b> Time lapse of a double pendulum trajectory from the IBM
                    dataset [<a href="#sec:references">8</a>].</p>
            </div>
        </div>
        <p>
            Since we know that all trajectories in this dataset stem from the same double
            pendulum [<a href="#sec:references">8</a>], we only used a single reference trajectory as target trajectory
            $\trajectory\real$ during the estimation. We let each estimator run for 2000 iterations. For evaluation, we
            calculate the consistency metrics from Tab.~1 of the main paper over 10 held-out trajectories from a test
            dataset. For comparison, we visualize the trajectory density over simulations rolled out from the last 100
            Markov samples (or 100 particles in the case of particle-based approaches) in
            <a href="#fig:ibm-pendulum-rollouts">Figure 3</a>. The ground-truth shown in these plots again stems from
            the unseen test
            dataset. This experiment further demonstrates the generalizability of simulation-based inference, which,
            when an adequate model has been implemented and its parameters identified, can predict outcomes under
            various novel conditions even though the training dataset consisted of only a single trajectory in this
            example.
        </p>


        <div class="row" id="fig:ibm-pendulum-rollouts">
            <div class="col"></div>
            <div class="col-8">
                <table class="table table-borderless table-hover align-middle">
                    <tr>
                        <th>
                            Emcee </th>
                        <td>
                            <img src="img/ibm_pendulum/mcmc_trajectories.png" alt="Emcee" class="img-fluid" />
                        </td>
                    </tr>
                    <tr>
                        <th>
                            CEM </th>
                        <td>
                            <img src="img/ibm_pendulum/cem_trajectories.png" class="img-fluid" alt="CEM" />
                        </td>
                    </tr>
                    <tr>
                        <th>
                            NUTS </th>
                        <td>
                            <img src="img/ibm_pendulum/nuts_trajectories.png" class="img-fluid" alt="NUTS" />
                        </td>
                    </tr>
                    <tr>
                        <th>
                            SGLD </th>
                        <td>
                            <img src="img/ibm_pendulum/sgld_trajectories.png" class="img-fluid" alt="SGLD" />
                        </td>
                    </tr>
                    <tr>
                        <th>
                            SVGD </th>
                        <td>
                            <img src="img/ibm_pendulum/svgd_ss_test.png" class="img-fluid" alt="SVGD" />
                        </td>
                    </tr>
                    <tr>
                        <th>
                            CSVGD </th>
                        <td>
                            <img src="img/ibm_pendulum/svgd_ms_test.png" class="img-fluid" alt="CSVGD" />
                        </td>
                    </tr>
                </table>
                <p>
                    <b>Figure 3.</b> Kernel density estimation over trajectory roll-outs from the last estimated 100
                    parameter guesses of each method, applied to the physical double pendulum dataset from
                    <a href="#sec:ibm-pendulum">Section 2.2</a>. The ground-truth trajectory here stems from the test
                    dataset of 10
                    trajectories that were held out during training. The particle-based approaches (CEM, SVGD, CSVGD)
                    use 100 particles.
                </p>
            </div>
            <div class="col"></div>
        </div>

        <h4 id="sec:exp-multiple-shooting">2.3 Ablation Study on Multiple Shooting</h4>

        <p>
            We evaluate the baseline estimation algorithms with our proposed multiple-shooting likelihood
            function
            (using
            10 shooting windows) on the physical double pendulum dataset from before. To make the constrained
            optimization problem amenable to the MCMC samplers, we formulate the defect constraint through the
            following
            likelihood:
            $$
            \begin{align}
            \pdef(\statevec_t^s, \statevec_t) = \mathcal{N}(\statevec_t^s | \statevec_t,\sigma^2_{\text{def}})
            \qquad
            t\in [h, 2h, \dots],
            \end{align}
            $$
            where we tune $\sigma^2_{\text{def}}$ to a small value (on the order of $10^{-2}$) such that the
            defects are
            minimized during the estimation. As we describe in Sec. 4.4 from our main paper, the parameter space
            is
            augmented by the shooting variables $\statevec_t^s$.
        </p>
        <p>
            As shown in <a href="#tab:ms-baselines">Table 2</a>, the MCMC approaches Emcee and NUTS do not benefit
            meaningfully from
            the multiple-shooting approach. Emcee often yields unstable simulations from which we are not able
            to
            compute some of the metrics. The increased dimensionality of the parameter space appears to add a
            significant challenge to these methods, which are known to scale poorly to higher dimensions.
            Despite being configured to use a Gaussian mixture model of 3 kernels, the CEM posterior immediately
            collapses to a single point such that the KL divergence of simulated against real trajectories
            cannot be computed.
        </p>

        <table class="table numbers" id="tab:ms-baselines">
            <thead>
                <tr>
                    <th scope="col"></th>
                    <th scope="col" colspan="2" style="text-align:center">$d_{\text{KL}} (\trajectoryset\real
                        \parallel
                        \trajectoryset\simu)$</th>
                    <th scope="col" colspan="2" style="text-align:center">$d_{\text{KL}} (\trajectoryset\simu
                        \parallel
                        \trajectoryset\real)$</th>
                    <th scope="col" colspan="2" style="text-align:center">MMD</th>
                </tr>
                <tr>
                    <th>Algorithm</th>
                    <th style="text-align:center">SS</th>
                    <th style="text-align:center">MS</th>
                    <th style="text-align:center">SS</th>
                    <th style="text-align:center">MS</th>
                    <th style="text-align:center">SS</th>
                    <th style="text-align:center">MS</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th> Emcee </th>
                    <td class="text-primary"> 8542.2466 </td>
                    <td> 8950.4574 </td>
                    <td> 4060.6312 </td>
                    <td>N/A </td>
                    <td> 1.1365 </td>
                    <td> N/A </td>
                </tr>
                <tr>
                    <th> CEM </th>
                    <td> 8911.1798 </td>
                    <td class="text-primary"> 8860.5115 </td>
                    <td> 8549.5927 </td>
                    <td>N/A </td>
                    <td> 0.9687 </td>
                    <td class="text-primary"> 0.5682 </td>
                </tr>
                <tr>
                    <th> SGLD </th>
                    <td> 8788.0962 </td>
                    <td class="text-primary"> 5863.2728 </td>
                    <td> 7876.0310 </td>
                    <td class="text-primary">2187.2825 </td>
                    <td> 2.1220 </td>
                    <td class="text-primary"> 0.0759 </td>
                </tr>
                <tr>
                    <th> NUTS </th>
                    <td> 9196.7461 </td>
                    <td class="text-primary"> 8785.5326 </td>
                    <td> 6432.2131 </td>
                    <td class="text-primary">4935.8983 </td>
                    <td class="text-primary"> 0.5371 </td>
                    <td> 1.1642 </td>
                </tr>
                <tr>
                    <th> (C)SVGD </th>
                    <td> 8803.5683 </td>
                    <td class="text-primary"> 5204.5336 </td>
                    <td> 10283.6659</td>
                    <td class="text-primary"> 2773.1751 </td>
                    <td> 0.7177 </td>
                    <td class="text-primary"> 0.0366 </td>
                </tr>
            </tbody>
        </table>
        <p>
            <b>Table 2.</b> Consistency metrics of the posterior distributions approximated from the physical
            double pendulum dataset (<a href="#sec:ibm-pendulum">Section 2.2</a>) by the different estimation algorithms
            using the
            single-shooting likelihood $p_{ss}(\trajectory\real | \params)$ (column "SS") and the
            multiple-shooting
            likelihood $p_{ms}(\trajectory\real | \params)$ (column "MS") with 10 shooting windows. Note that
            SVGD with multiple-shooting corresponds to CSVGD.
        </p>

        <p>
            We observe a significant improvement in estimation accuracy on SGLD, where the multiple-shooting
            approach
            allowed it to converge to closely matching trajectories, as shown in <a href="#fig:sgld-ms">Figure 4</a>. As
            with
            SVGD,
            the availability of gradients allows this method to scale better to the higher dimensional parameter
            space,
            while the smoothed likelihood landscape further helps the approach to find better fitting
            parameters.
        </p>

        <div class="row" id="fig:sgld-ms">
            <div class="col"></div>
            <div class="col-8">
                <img src="img/ibm_pendulum/sgld_ms.png" class="img-fluid" alt="SGLD with Multiple Shooting" />
                <p>
                    <b>Figure 4.</b> Kernel density estimation over trajectory roll-outs from the last estimated 100
                    parameter guesses of SGLD with the multiple-shooting likelihood model (see
                    <a href="#sec:exp-multiple-shooting">Section 2.3</a>), applied to the physical double pendulum
                    dataset from
                    <a href="#sec:ibm-pendulum">Section 2.2</a>. Similarly to SVGD, SGLD benefits significantly from the
                    smoother
                    likelihood function while being able to cope with the augmented parameter space thanks to its
                    gradient-based approach.
                </p>
            </div>
            <div class="col"></div>
        </div>

        <h4 id="sec:likelihoodfree">2.4 Comparison to Likelihood-free Inference</h4>
        <p>
            Our Bayesian inference approach leverages the simulator as part of the likelihood model to
            approximate posterior distributions over simulation parameters, which means the simulator is indispensable
            in our estimation process}. In the following, we compare our approach against the likelihood-free inference
            approach BayesSim [<a href="#sec:references">9</a>] that leverages approximate Bayesian computation (ABC)
            which is
            the most popular family of algorithms within likelihood-free methods.
        </p>

        <p>
            Likelihood-free methods assume the simulator is a black box that can generate a trajectory given a parameter
            setting. Instead of querying the simulator to evaluate the likelihood (as in our approach), a conditional
            density $q(\params | \trajectoryset)$ is learned directly from a dataset of simulation parameters and their
            corresponding rolled-out trajectories via supervised learning to approximate the posterior. A common choice
            of model for such density is a mixture density network [<a href="#sec:references">10</a>], which
            parameterizes a
            Gaussian mixture model. This is in contrast to our (C)SVGD algorithm which can approximate
            any shape of posterior by being a nonparametric inference algorithm.
        </p>
        </p>

        <p>
            For our experiments we collect a dataset of 10,000 simulated trajectories of parameters randomly sampled
            from the prior distribution. We train the density network via the Adam optimizer with a learning rate of
            $10^{-3}$ for 3000 epochs, after which we observed no meaningful improvement to the calculated
            log-likelihood loss during training. In the following, we provide further details on the likelihood-free
            inference pipeline we consider, by describing the input data processing and the model used for approximating
            the posterior.
        </p>
        <h5 id="sec:bayessim-input">2.4.1 Input Data Processing</h5>
        <p>
            The input to the learned density model has to be a sufficient statistic of the underlying data, while being
            low-dimensional in order to keep the learning problem computationally tractable. We consider the following
            four methods of processing the trajectories that are the input to the likelihood-free methods, as
            visualized for an example trajectory in <a href="#fig:bayessim-inputs">Figure 5</a>. Note that we configured
            the following
            input processing methods to generate a one-dimensional input vector that has a reasonable length to be
            computationally feasible to train on (given the 10,000 trajectories from the training dataset), while
            achieving acceptable performance which we validated through testing various settings.
        </p>

        <p>
            <b>Downsampled:</b> we down-sample the trajectory so that for the double pendulum experiment
            (<a href="#sec:ibm-pendulum">Section 2.2</a>) we use only every 20th state, for the Panda arm experiment
            (<a href="#sec:panda-box">Section 2.5</a>) only every 200-th state of the trajectory. Finally, the state
            dimensions per
            trajectory are concatenated to a one-dimensional vector.
        </p>
        <p>
            <b>Difference:</b> we adapt the input statistic from the original BayesSim approach in [<a
                href="#sec:references">9</a>, Eq. (22)] where the differences of two consecutive states along the
            trajectory are used in
            concatenation with their mean and variance:
            $$
            \psi(\trajectory) = (\operatorname{downsample}(\tau), \mathbb{E}[\tau], \operatorname{Var}[\tau])
            \qquad\text{where}\qquad
            \tau = \{\statevec_t - \statevec_{t-1}\}_{t=1}^T
            $$
            As before, we down-sample these state differences and concatenate them to a vector.
        </p>
        <p>
            <b>Summary:</b> for each state dimension of the trajectory, we compute the following statistics typical for
            time series: mean, variance, cross correlation between state dimensions of the trajectory, as well as
            auto-correlations for each dimension at 5 different time delays: [5, 10, 20, 50, 100] time steps.
            These numbers are concatenated for all state dimensions to a one-dimensional vector per input
            trajectory.
        </p>
        <p>
            <b>Signature:</b> we compute the signature transform from the signatory package [<a
                href="#sec:references">11</a>]
            over the input trajectory. Such so-called path signatures have been recently introduced to extract
            information about order and area, thereby preserving features inherent to nonlinear trajectories. We select
            a depth for the signature transform of 3 for the double pendulum experiment, and 2 for the Panda arm
            experiment, to obtain feature vectors of comparable size to the aforementioned input techniques.
        </p>

        <div class="row" id="fig:bayessim-inputs">
            <div class="col">
                <img src="img/ibm_pendulum/bayes_sim/ibm_groundtruth_raw.png" class="img-fluid" alt="Ground Truth" />
                <p style="text-align: center;">(a) Raw Input</p>
            </div>
            <div class="col">
                <img src="img/ibm_pendulum/bayes_sim/ibm_groundtruth_downsampled.png" class="img-fluid"
                    alt="Downsampled" />
                <p style="text-align: center;">(b) Downsampled</p>
            </div>
            <div class="col">
                <img src="img/ibm_pendulum/bayes_sim/ibm_groundtruth_difference.png" class="img-fluid"
                    alt="Difference" />
                <p style="text-align: center;">(c) Difference</p>
            </div>
            <div class="col">
                <img src="img/ibm_pendulum/bayes_sim/ibm_groundtruth_summary.png" class="img-fluid" alt="Summary" />
                <p style="text-align: center;">(d) Summary</p>
            </div>
            <div class="col">
                <img src="img/ibm_pendulum/bayes_sim/ibm_groundtruth_signature.png" class="img-fluid" alt="Signature" />
                <p style="text-align: center;">(e) Signature</p>
            </div>
        </div>
        <p>
            <b>Figure 5.</b> Exemplary visualization of the input processing methods for the likelihood-free baselines
            from <a href="#sec:likelihoodfree">Section 2.4</a> applied to a trajectory from the double pendulum
            experiment in
            <a href="#sec:ibm-pendulum">Section 2.2</a>.
        </p>

        <h5 id="sec:bayessim-model">2.4.2 Density Model</h5>
        <p>
            As the density model for the learned posterior $q(\params | \trajectoryset)$, we select the following
            commonly used representations.
        </p>
        <p>
            <b>Mixture density network (<b>MDN</b>):</b> uses neural network features from a feed-forward neural network
            using two hidden layers with 24 units each.
        </p>
        <p>
            <b>Mixture density random Fourier features (<b>MDRFF</b>):</b> this density model uses Fourier features and
            a kernel. We evaluate the MDRFF with the following common choices for the kernel:
        <ul>
            <li> Radial Basis Function (<b>RBF</b>) kernel </li>
            <li> <b>Matérn</b> kernel [<a href="#sec:references">12</a>, Eq. (4.14)] with $\nu=\frac{5}{2}$ </li>
        </ul>

        <h5 id="sec:bayessim-eval">2.4.3 Evaluation</h5>
        <p>
            Note that instead of action generation, which is part of the proposed BayesSim
            pipeline [<a href="#sec:references">9</a>], we only focus on the inference of the posterior density over
            simulation
            parameters in order to compare such likelihood-free inference approach against our method.
        </p>
        <p>
            To evaluate the metrics shown in <a href="#tab:likelihoodfree-results">Table 2</a> for each BayesSim
            instantiation (input method and density model), we sample 100 parameter vectors from the learned
            posterior $q(\params | \trajectoryset)$ and simulate them to obtain 100 trajectories which are compared
            against the reference trajectory sets, as we did in the comparison for the other Bayesian inference methods
            in Tab. 1 of the main paper.
        </p>

        <table class="table numbers" id="tab:likelihoodfree-results">
            <thead>
                <td></td>
                <td></td>
                <th colspan="3" style="text-align:center" class="border-start border-end">Double Pendulum Experiment
                </th>
                <th style="text-align:center"> Panda Arm Experiment </th>
                </tr>
                <tr>
                    <th> Input </th>
                    <th> Model </th>
                    <th class="border-start" style="text-align:center"> $d_{\text{KL}} (\trajectoryset\real \parallel
                        \trajectoryset\simu)$
                    </th>
                    <th style="text-align:center"> $d_{\text{KL}} (\trajectoryset\simu \parallel \trajectoryset\real)$
                    </th>
                    <th class="border-end" style="text-align:center"> MMD
                    </th>
                    <th style="text-align:center"> $\log\pobs(\trajectoryset\real \parallel \trajectoryset\simu)$ </th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>Downsampled </th>
                    <th class="border-end"> MDN </th>
                    <td> 8817.9222 </td>
                    <td> 4050.4666 </td>
                    <td class="border-end"> 0.6748 </td>
                    <td> -17.4039 </td>
                </tr>
                <tr>
                    <th>Difference </th>
                    <th class="border-end"> MDN </th>
                    <td> 8919.2463 </td>
                    <td> 4633.2637 </td>
                    <td class="border-end"> 0.6285 </td>
                    <td> -17.1646 </td>
                </tr>
                <tr>
                    <th>Summary </th>
                    <th class="border-end"> MDN </th>
                    <td> 9092.5575 </td>
                    <td> 5093.8851 </td>
                    <td class="border-end"> 0.5664 </td>
                    <td> -18.3481 </td>
                </tr>
                <tr>
                    <th>Signature </th>
                    <th class="border-end"> MDN </th>
                    <td> 8985.8056 </td>
                    <td> 4610.5438 </td>
                    <td class="border-end"> 0.5807 </td>
                    <td> -19.3432 </td>
                </tr>
                <tr>
                    <th>Downsampled </th>
                    <th class="border-end"> MDRFF (RBF) </th>
                    <td> 9027.9474 </td>
                    <td> 5091.5283 </td>
                    <td class="border-end"> 0.5593 </td>
                    <td> -17.2335 </td>
                </tr>
                <tr>
                    <th>Difference </th>
                    <th class="border-end"> MDRFF (RBF) </th>
                    <td> 8936.3823 </td>
                    <td> 4282.8599 </td>
                    <td class="border-end"> 0.5988 </td>
                    <td> -18.4892 </td>
                </tr>
                <tr>
                    <th>Summary </th>
                    <th class="border-end"> MDRFF (RBF) </th>
                    <td> 9063.1753 </td>
                    <td> 4884.1398 </td>
                    <td class="border-end"> 0.5672 </td>
                    <td> -19.5430 </td>
                </tr>
                <tr>
                    <th>Signature </th>
                    <th class="border-end"> MDRFF (RBF) </th>
                    <td> 8980.9080 </td>
                    <td> 4081.1160 </td>
                    <td class="border-end"> 0.6016 </td>
                    <td> -18.3458 </td>
                </tr>
                <tr>
                    <th>Downsampled </th>
                    <th class="border-end"> MDRFF (Matérn) </th>
                    <td> 8818.1830 </td>
                    <td> 3794.9873 </td>
                    <td class="border-end"> 0.6110 </td>
                    <td> -17.6395 </td>
                </tr>
                <tr>
                    <th>Difference </th>
                    <th class="border-end"> MDRFF (Matérn) </th>
                    <td> 8859.2156 </td>
                    <td> 4349.9971 </td>
                    <td class="border-end"> 0.6176 </td>
                    <td> -17.2752 </td>
                </tr>
                <tr>
                    <th>Summary </th>
                    <th class="border-end"> MDRFF (Matérn) </th>
                    <td> 8962.0501 </td>
                    <td> 4241.4551 </td>
                    <td class="border-end"> 0.5999 </td>
                    <td> -19.6672 </td>
                </tr>
                <tr>
                    <th>Signature </th>
                    <th class="border-end"> MDRFF (Matérn) </th>
                    <td> 9036.9626 </td>
                    <td> 4620.9517 </td>
                    <td class="border-end"> 0.5715 </td>
                    <td> -18.1652 </td>
                </tr>
                <tr>
                    <th colspan="2" style="text-align:center" class="border-end">CSVGD </th>
                    <td class="text-primary"> 5204.5336 </td>
                    <td class="text-primary"> 2773.1751 </td>
                    <td class="text-primary border-end"> 0.0366 </td>
                    <td class="text-primary"> -15.1671 </td>
                </tr>
            </tbody>
        </table>
        <p>
            <b>Table 2.</b>
            Consistency metrics of the posterior distributions approximated by the different BayesSim instantiations,
            where the input method and model name (including the kernel type for the MDRFF model) are given. Each metric
            is calculated across simulated and real trajectories. Lower is better on all metrics except the
            log-likelihood $\log\pobs(\trajectoryset\real \parallel \trajectoryset\simu)$ from the Panda arm experiment.
            For comparison, in the last row, we reproduce the numbers from CSVGD shown in Tab. 1 of the main paper.
        </p>


        <table class="table table-borderless table-hover centered" id="fig:ibm-pendulum-rollouts-bayessim">
            <tr>
                <td width="50%">
                    <img src="img/ibm_pendulum/bayes_sim/bayessim_ibm_pendulum_mdn_downsampled_trajectories.png"
                        class="img-fluid" />
                    <p><b>MDN</b> - Downsampled</p>

                </td>
                <td width="50%">
                    <img src="img/ibm_pendulum/bayes_sim/bayessim_ibm_pendulum_mdn_difference_trajectories.png"
                        class="img-fluid" />
                    <p><b>MDN </b>- Difference </p>
                </td>
            </tr>
            <tr>
                <td>
                    <img src="img/ibm_pendulum/bayes_sim/bayessim_ibm_pendulum_mdn_summary_trajectories.png"
                        class="img-fluid" />
                    <p><b>MDN</b> - Summary </p>
                </td>
                <td>
                    <img src="img/ibm_pendulum/bayes_sim/bayessim_ibm_pendulum_mdn_signature_trajectories.png"
                        class="img-fluid" />
                    <p><b>MDN</b> - Signature </p>
                </td>
            </tr>
            <tr>
                <td>
                    <img src="img/ibm_pendulum/bayes_sim/bayessim_ibm_pendulum_mdrff_rbf_downsampled_trajectories.png"
                        class="img-fluid" />
                    <p><b>MDRFF (RBF)</b> - Downsampled </p>
                </td>
                <td>
                    <img src="img/ibm_pendulum/bayes_sim/bayessim_ibm_pendulum_mdrff_rbf_difference_trajectories.png"
                        class="img-fluid" />
                    <p><b>MDRFF (RBF)</b> - Difference </p>
                </td>
            </tr>
            <tr>
                <td>
                    <img src="img/ibm_pendulum/bayes_sim/bayessim_ibm_pendulum_mdrff_rbf_summary_trajectories.png"
                        class="img-fluid" />
                    <p><b>MDRFF (RBF)</b> - Summary </p>
                </td>
                <td>
                    <img src="img/ibm_pendulum/bayes_sim/bayessim_ibm_pendulum_mdrff_rbf_signature_trajectories.png"
                        class="img-fluid" />
                    <p><b>MDRFF (RBF)</b> - Signature </p>
                </td>
            </tr>
            <tr>
                <td>
                    <img src="img/ibm_pendulum/bayes_sim/bayessim_ibm_pendulum_mdrff_matern_downsampled_trajectories.png"
                        class="img-fluid" />
                    <p><b>MDRFF (Matérn)</b> - Downsampled </p>
                </td>
                <td>
                    <img src="img/ibm_pendulum/bayes_sim/bayessim_ibm_pendulum_mdrff_matern_difference_trajectories.png"
                        class="img-fluid" />
                    <p><b>MDRFF (Matérn)</b> - Difference </p>
                </td>
            </tr>
            <tr>
                <td>
                    <img src="img/ibm_pendulum/bayes_sim/bayessim_ibm_pendulum_mdrff_matern_summary_trajectories.png"
                        class="img-fluid" />
                    <p><b>MDRFF (Matérn)</b> - Summary </p>
                </td>
                <td>
                    <img src="img/ibm_pendulum/bayes_sim/bayessim_ibm_pendulum_mdrff_matern_signature_trajectories.png"
                        class="img-fluid" />
                    <p><b>MDRFF (Matérn)</b> - Signature </p>
                </td>
            </tr>
        </table>
        <p>
            <b>Figure 6.</b> Kernel density estimation over trajectory roll-outs from 100 parameter samples drawn from
            the posterior of each BayesSim method (model name with kernel choice in bold font + input method, see
            <a href="#sec:likelihoodfree">Section 2.4</a>), applied to the physical double pendulum dataset from
            <a href="#sec:ibm-pendulum">Section 2.2</a>. The ground-truth trajectory here stems from the test dataset of
            10 trajectories
            that were held out during training.
        </p>

        <h5>2.4.4 Discussion</h5>

        <p>
            The results from our experiments with the various likelihood-free approaches in
            <a href="#tab:likelihoodfree-results">Table 2</a> indicate that, among the tested pipelines, the MDRFF model
            with Matérn
            kernel and downsampled trajectory input overall performed the strongest, followed by the MDN with
            downsampled input. In comparison to the likelihood-based algorithms from Tab.~1 of the main paper, these
            results are comparable on the double pendulum experiment. However, in comparison to CSVGD, the estimated
            likelihood-free posteriors are significantly less accurate, which can also be clearly seen in the density
            plots over the rolled out trajectories from such learned densities in
            <a href="#fig:ibm-pendulum-rollouts-bayessim">Figure 6</a>. On the Panda arm experiment, the likelihood-free
            methods are
            outperformed by the likelihood-based algorithms (such as the Emcee sampler) more often on the likelihood of
            the learned parameter densities. CSVGD again achieves a much more accurate posterior in this experiment than
            any likelihood-free approach.
        </p>

        <p class="lead">Why do these likelihood-free methods perform so poorly on a seemingly simple double pendulum?
        </p>
        <p>
            One would expect that this kind of dynamical system poses no greater challenge to BayesSim when it was shown
            to identify a cartpole's link length and cart mass successfully [<a href="#sec:references">9</a>]. To
            investigate
            this problem, we revisit the simplified double pendulum estimation experiment from Sec. 5.1 of our main
            paper, where only the two link lengths need to be estimated from simulated trajectories. As before, we
            create a dataset with 10,000 trajectories of 400 time steps based on the two simulation parameters sampled
            from a uniform distribution ranging between 0.5m and 5m. While keeping all
            parameters the same as in our previous double-pendulum experiment where eleven parameters had to be
            inferred, all of the density models in combination with both the "difference" and "downsampled" input
            statistic infer a highly accurate parameter distribution, as shown in
            <a href="#fig:bayessim-twoparam-posterior">Figure 7 (a)</a>. The trajectories produced by sampling from the
            BayesSim posterior
            (<a href="#fig:bayessim-twoparam-trajectories">Figure 7 (b)</a>) also match the reference observations much
            more closely than
            any of the BayesSim models on the previous 11-parameter double
            pendulum~(<a href="#fig:ibm-pendulum-rollouts-bayessim">Figure</a>). These results suggest that BayesSim and
            potentially
            other likelihood-free method have problems in inferring higher dimensional parameter distributions. The
            experiments in [<a href="#sec:references">9</a>] demonstrated as many as four parameters being estimated
            (for the
            acrobot), while showing inference results for simulated systems only. While our double pendulum system from
            <a href="#sec:ibm-pendulum">Section 2.2</a> is basic in principle, the higher dimensional parameter space
            (see parameters in
            <a href="#tab:params-ibm-pendulum">Table 1</a>) and the fact that we need to fit against real-world data
            makes it a
            significantly harder problem for most state-of-the-art inference algorithms. CSVGD is able to achieve a
            close fit thanks to the multiple-shooting segmentation of the trajectory which improves the convergence (see
            more ablation results for multiple-shooting on this experiment in <a
                href="#sec:exp-multiple-shooting">Section 2.3</a>).
        </p>

        <div class="row">
            <div class="col"></div>
            <div class="col-4" id="fig:bayessim-twoparam-posterior">
                <img src="img/synthetic_param_uncertainty/bayessim_twoparam_mdn_downsampled.png" class="img-fluid" />
                <p style="text-align: center;">(a) Posterior</p>
            </div>
            <div class="col-4" id="fig:bayessim-twoparam-trajectories">
                <img src="img/synthetic_param_uncertainty/bayessim_two_param_mdn_downsampled_trajectories.png"
                    class="img-fluid" />
                <p style="text-align: center;">(b) Trajectory density</p>
            </div>
            <div class="col"></div>
        </div>
        <div class="row">
            <div class="col"></div>
            <div class="col-8">
                <p>
                    <b>Figure 7.</b> Results from BayesSim on the simplified double pendulum experiment where only the
                    two link lengths need to be inferred. (a) shows the approximated posterior distribution by the MDN
                    model and "downsampled" input statistics. The diagonal plots show the marginal parameter
                    distributions, the bottom-left heatmap and the top-right contour plot show the 2D posterior where
                    the ground-truth parameters at (1.5m, 2m) are indicated by a red star. The
                    black dots in the top-right plot are 100 parameters sampled from the posterior which are rolled out
                    to generate trajectories for the trajectory density plot in (b). (b) shows a kernel density
                    estimation over these 100 trajectories for the four state dimensions
                    $(\jointpos_{[0:1]},\jointvel_{[0:1]})$ of the double pendulum.
                </p>
            </div>
            <div class="col"></div>
        </div>

        <h4 id="sec:panda-box">2.5 Identify Inertia of an Articulated Rigid Object</h4>
        <p>
            The state space consists of the positions and velocities of the seven degrees of freedom of the robot arm
            and the two degrees of freedom in the universal joint, resulting in a 20-dimensional state vector
            $\statevec=\begin{bmatrix}\mathbf{q}_{0:8} & \mathbf{\dot{q}}_{0:8} & \mathbf{q}^d_{0:6} &
            \mathbf{\dot{q}}^d_{0:6}\end{bmatrix}$
            consisting of nine joint positions and velocities, plus the PD control position and velocity targets,
            $\mathbf{q}^d$ and $\mathbf{\dot{q}}^d$, for the actuated joints of the robot arm. We control the arm using
            the <em>MoveIt!</em> motion planning framework [<a href="#sec:references">13</a>] by moving joints 6 and 7
            to
            predefined joint-space offsets of $0.1$ and $-0.1$ radians, in sequence. We use the default Iterative
            Parabolic Time Parameterization algorithm with a velocity scaling factor of $0.1$. We track the motion of
            the acrylic box via a Vicon motion capture system and derive four Cartesian coordinates as observation
            $\observationvec=\begin{bmatrix}\mathbf{p}_{o} & \mathbf{p}_{x} & \mathbf{p}_{y} &
            \mathbf{p}_{z}\end{bmatrix}$ to represent the
            frame of the box (shown in <a href="#fig:panda-markers">Figure 8</a>): a point of origin located at the
            center of the
            upper lid of the box, and three points located 1m away from the origin into the x, y, and z
            direction (transformed by the reference frame of the box). We chose this state representation to ease the
            computation of the likelihood, since we only need to compute differences between 3D points instead of
            computing the distances over 3D rotations which requires special treatment [<a
                href="#sec:references">14</a>].
        </p>
        <div class="row" id="fig:panda-markers">
            <div class="col"></div>
            <div class="col-8" id="fig:bayessim-twoparam-posterior">
                <img src="img/panda/panda_sim_markers.png" class="img-fluid" />
                <p>
                    <b>Figure 8.</b> Rendering of the simulation for the underactuated mechanism from
                    <a href="#sec:panda-box">Section 2.5</a>, where the four reference points for the origin, unit x, y,
                    and z vectors
                    are shown. The trace of the simulated trajectory is visualized by the solid lines, the ground-truth
                    trajectories of the markers are shown as dotted lines.
                </p>
            </div>
            <div class="col"></div>
        </div>
        <p>
            We first identify the simulation parameters pertaining to the inertial properties of the box and the
            friction parameters of the universal joint. As shown in <a href="#tab:params-panda-box-phase1">Table 3
                (a)</a>, the symmetric
            inertia matrix of the box is fully determined by the first six parameters, followed by the 3D center of
            mass. We have measured the mass to be 920g, so we do not need to estimate it. We simulate the
            universal joint with velocity-dependent damping, with possibly different friction coefficients for both
            degrees of freedom. The simulation parameters yielding the most accurate fit to a ground-truth trajectory
            from the physical robot shaking an empty box is shown in <a href="#fig:panda-box-trajectory">Figure 9</a>.
            We were able to
            find such parameters via SVGD, CSVGD and Emcee (shown is a parameter configuration from the particle
            distribution estimated by CSVGD with the highest likelihood).
        </p>

        <p>
            While the simulated trajectory matches the real data significantly better after the inertial parameters of
            the empty box have been identified (<a href="#fig:panda-box-trajectory-after">Figure 9 (b)</a>) than before
            (<a href="#fig:panda-box-trajectory-before">Figure (a)</a>), a reality gap remains. We believe this to be a
            result from a
            slight modeling error that the rigid body simulator cannot capture, e.g. the top of the box where the
            universal joint is attached bends slightly while the box is moving, and there may be slight geometric
            offsets between the real system and the model of it we use in the simulator. The latter parameters could
            have been further identified with our approach, nonetheless the simulation given the identified parameters
            is sufficient to be used in the next phase of the inference experiment.
        </p>

        <div class="row" id="fig:panda-box-trajectory">
            <div class="col-6" id="fig:panda-box-trajectory-before">
                <img src="img/panda/panda_box_initial_trajectory.png" class="img-fluid" />
                <p style="text-align: center;">(a) Before identification of empty box</p>
            </div>
            <div class="col-6" id="fig:panda-box-trajectory-after">
                <img src="img/panda/panda_box_trajectory.png" class="img-fluid" />
                <p style="text-align: center;">(b) After identification of empty box</p>
            </div>
        </div>
        <p>
            <b>Figure 9.</b> Trajectories from the Panda robot arm shaking an empty box. Visualized are the
            simulated (red) and real (black) observations before (a) and after (b) the inertial parameters of
            the empty box and the friction from the universal joint (<a href="#tab:params-panda-box-phase1">Table 3
                (a)</a>) have been
            identified. The columns correspond to the four reference points in the frame of the box (see a rendering of
            them in <a href="#fig:panda-markers">Figure 8</a>), the rows show the $x$, $y$, and $z$ axes of these
            reference points in
            meters. The horizontal axes show the time step.
        </p>

        <p>
            Given the parameters found in the first phase, we now investigate how well the various approaches can cope
            with dependent variables. By fixing two 500g to the bottom of the acrylic box, the 2D locations
            of such weights need to be inferred. Naturally, such assignment is symmetric, i.e. weight 1 and 2 can swap
            locations without affecting the dynamics. What would significantly alter the dynamics, however, is an
            unbalanced configuration of the weights which would cause the box to tilt.
        </p>

        <div class="row" id='tab:params-panda-box'>
            <div class="col"></div>
            <div class="col-5">
                <table class="table" id="tab:params-panda-box-phase1">
                    <thead>
                        <tr>
                            <th scope="col"></th>
                            <th scope="col">Parameter</th>
                            <th scope="col" colspan="2" style="text-align:center">Minimum</th>
                            <th scope="col" colspan="2" style="text-align:center">Maximum</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <th rowspan="9">Box</th>
                            <th> $I_{xx}$ </th>
                            <td align="right"> 0.05 </td>
                            <td> $\kg\cdot\meter^2$ </td>
                            <td align="right"> 0.1 </td>
                            <td> $\kg\cdot\meter^2$ </td>
                        </tr>
                        <tr>
                            <th> $I_{yy}$ </th>
                            <td align="right"> 0.05 </td>
                            <td> $\kg\cdot\meter^2$ </td>
                            <td align="right"> 0.1 </td>
                            <td> $\kg\cdot\meter^2$ </td>
                        </tr>
                        <tr>
                            <th> $I_{zz}$ </th>
                            <td align="right"> 0.05 </td>
                            <td> $\kg\cdot\meter^2$ </td>
                            <td align="right"> 0.1 </td>
                            <td> $\kg\cdot\meter^2$ </td>
                        </tr>
                        <tr>
                            <th> $I_{xy}$ </th>
                            <td align="right"> -0.01 </td>
                            <td> $\kg\cdot\meter^2$ </td>
                            <td align="right"> 0.01 </td>
                            <td> $\kg\cdot\meter^2$ </td>
                        </tr>
                        <tr>
                            <th> $I_{xz}$ </th>
                            <td align="right"> -0.01 </td>
                            <td> $\kg\cdot\meter^2$ </td>
                            <td align="right"> 0.01 </td>
                            <td> $\kg\cdot\meter^2$ </td>
                        </tr>
                        <tr>
                            <th> $I_{yz}$ </th>
                            <td align="right"> -0.01 </td>
                            <td> $\kg\cdot\meter^2$ </td>
                            <td align="right"> 0.01 </td>
                            <td> $\kg\cdot\meter^2$ </td>
                        </tr>
                        <tr>
                            <th> COM $x$ </th>
                            <td align="right"> -0.005 </td>
                            <td> $\meter$ </td>
                            <td align="right"> 0.005 </td>
                            <td> $\meter$ </td>
                        </tr>
                        <tr>
                            <th> COM $y$ </th>
                            <td align="right"> -0.005 </td>
                            <td> $\meter$ </td>
                            <td align="right"> 0.005 </td>
                            <td> $\meter$ </td>
                        </tr>
                        <tr>
                            <th> COM $z$ </th>
                            <td align="right"> 0.1 </td>
                            <td> $\meter$ </td>
                            <td align="right"> 0.4 </td>
                            <td> $\meter$</td>
                        </tr>

                        <tr>
                            <th rowspan="2">U-Joint</th>
                            <th> Friction DOF 1 </th>
                            <td align="right"> 0.0 </td>
                            <td> </td>
                            <td align="right"> 0.15 </td>
                            <td></td>
                        </tr>
                        <tr>
                            <th> Friction DOF 2 </th>
                            <td align="right"> 0.0 </td>
                            <td> </td>
                            <td align="right"> 0.15 </td>
                            <td> </td>
                        </tr>
                    </tbody>
                </table>
                <p style="text-align: center;">(a) Phase I</p>

            </div>
            <div class="col"></div>
            <div class="col-4">
                <table class="table" id="tab:params-panda-box-phase2">
                    <thead>
                        <tr>
                            <th scope="col"></th>
                            <th scope="col">Parameter</th>
                            <th scope="col" colspan="2" style="text-align:center">Minimum</th>
                            <th scope="col" colspan="2" style="text-align:center">Maximum</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <th rowspan="2">Weight 1</th>
                            <th> Position $x$ </th>
                            <td align="right"> -0.14 </td>
                            <td> $\meter$ </td>
                            <td align="right"> 0.14 </td>
                            <td>$\meter$</td>
                        </tr>
                        <tr>
                            <th> Position $y$ </th>
                            <td align="right"> -0.08 </td>
                            <td> $\meter$ </td>
                            <td align="right"> 0.08 </td>
                            <td>$\meter$</td>
                        </tr>
                        <tr>
                            <th rowspan="2">Weight 2</th>
                            <th> Position $x$ </th>
                            <td align="right"> -0.14 </td>
                            <td> $\meter$ </td>
                            <td align="right"> 0.14 </td>
                            <td>$\meter$</td>
                        </tr>
                        <tr>
                            <th> Position $y$ </th>
                            <td align="right"> -0.08 </td>
                            <td> $\meter$ </td>
                            <td align="right"> 0.08 </td>
                            <td>$\meter$</td>
                        </tr>
                    </tbody>
                </table>
                <p style="text-align: center;">(b) Phase II</p>

            </div>
            <div class="col"></div>
        </div>
        <p>
            <b>Table 3.</b> Parameters to be estimated and their ranges for the two estimation phases of the
            underactuated mechanism experiment from <a href="#sec:panda-box">Section 2.5</a>.
        </p>

        <p>
            We use 50 particles and run each estimation algorithm for 500 iterations. For each baseline method, we
            carefully tuned the hyper parameters to facilitate a fair comparison. Such tuning included selecting an
            appropriate measurement noise variance, which, as we observed on Emcee and SGLD in particular, had a
            significant influence on the exploration behavior of these algorithms. With a larger observation noise
            variance the resulting posterior distribution became wider, however we were unable to attain such behavior
            with the NUTS estimator whose iterates quickly collapsed to a single point at the center of the box (see
            <a href="#fig:panda-box-posterior-nuts">Figure 10 (d)</a>). Similarly, CEM immediately became stuck in the
            suboptimal
            configuration shown in <a href="#fig:panda-box-posterior-cem">Figure 10 (b)</a>. Nonetheless, after 500
            iterations, all methods
            predicted weight positions that were aligned opposite to one another to balance the box.
        </p>

        <p>
            As can be seen in <a href="#fig:panda-box-posterior-svgd">Figure 10 (e)</a>, SVGD achieves a fairly
            predictive posterior
            approximation, with many particles aligned close to the true vertical position at $y=0$. With the
            introduction of the multiple-shooting constraints, Constrained SVGD (CSVGD) converges significantly faster
            to a posterior distribution that accurately captures the true locations of the box, while retaining the
            exploration performance of SVGD that spreads out the particles over multiple modes, as shown in
            <a href="#fig:panda-box-posterior-csvgd">Figure 10 (f)</a>.
        </p>

        <div class="row" id="fig:panda-box-posterior">
            <div class="col-4" id="fig:panda-box-posterior-emcee">
                <img src="img/panda/box_position_emcee.png" alt="Emcee" class="img-fluid" />
                <p style="text-align: center;">(a) Emcee</p>
            </div>
            <div class="col-4" id="fig:panda-box-posterior-cem">
                <img src="img/panda/box_position_cem.png" alt="CEM" class="img-fluid" />
                <p style="text-align: center;">(b) CEM</p>
            </div>
            <div class="col-4" id="fig:panda-box-posterior-sgld">
                <img src="img/panda/box_position_sgld.png" alt="SGLD" class="img-fluid" />
                <p style="text-align: center;">(c) SGLD</p>
            </div>
            <div class="col-4" id="fig:panda-box-posterior-nuts">
                <img src="img/panda/box_position_nuts.png" alt="NUTS" class="img-fluid" />
                <p style="text-align: center;">(d) NUTS</p>
            </div>
            <div class="col-4" id="fig:panda-box-posterior-svgd">
                <img src="img/panda/box_position_svgd_ss.png" alt="SVGD" class="img-fluid" />
                <p style="text-align: center;">(e) SVGD</p>
            </div>
            <div class="col-4" id="fig:panda-box-posterior-csvgd">
                <img src="img/panda/box_position_svgd_ms.png" alt="CSVGD" class="img-fluid" />
                <p style="text-align: center;">(f) CSVGD</p>
            </div>
        </div>
        <p>
            <b>Figure 10.</b> Posterior plots over the 2D weight locations approximated by the estimation algorithms
            applied to the underactuated mechanism experiment from <a href="#sec:panda-box">Section 2.5</a>. Blue shades
            indicate a
            Gaussian kernel density estimation computed over the inferred parameter samples. Since it is an
            unbounded kernel density estimate, the blue shades cross the parameter boundaries in certain areas (e.g. for
            CSVGD), while in reality none of the estimated particles violate the parameter limits.
        </p>

        <h3 id="sec:references">References</h3>

        <style>
            ul.references {
                list-style-type: none;
                counter-reset: elementcounter;
                padding-left: 0;
                display: table;
            }

            .references li {
                display: table-row;
            }

            .references li:before {
                content: "["counter(elementcounter) "]";
                counter-increment: elementcounter;
                font-weight: normal;
                display: table-cell;
                padding-right: 1em;
            }
        </style>

        <ul class="references">
            <li>
                J. Burkardt. Sobol - the sobol quasirandom sequence.
                <a target="_blank"
                    href="https://people.sc.fsu.edu/271~jburkardt/cpp_src/sobol/sobol.html">https://people.sc.fsu.edu/271~jburkardt/cpp_src/sobol/sobol.html</a>.
                Accessed: 2021-06-23.
            </li>
            <li>
                B. L. Fox. Algorithm 647: Implementation and relative efficiency of quasirandom sequence generators.
                <em>ACM Trans. Math. Softw.</em>, 12(4):362–376, Dec. 1986. ISSN 0098-3500.
                <a target="_blank" href="http://dx.doi.org/10.1145/22721.356187">doi:10.1145/22721.356187</a>.
            </li>
            <li>
                R. Chou, Y. Boers, M. Podt, and M. Geist. Performance evaluation for particle filters. <em>In 14th
                    International Conference on Information Fusion</em>, pages 1–7, July 2011.
            </li>
            <li>
                Q. Wang, S. R. Kulkarni, and S. Verdu. Divergence Estimation for Multidimensional Densities Via
                $k$-Nearest-Neighbor Distances. <em>IEEE Transactions on Information Theory</em>,
                55(5):2392–2405, May 2009. ISSN 0018-9448. <a target="_blank"
                    href="http://ieeexplore.ieee.org/document/4839047/">doi:10.1109/TIT.2009.2016060</a>.
            </li>
            <li>
                E. Heiden, D. Millard, E. Coumans, Y. Sheng, and G. S. Sukhatme.
                NeuralSim: Augmenting differentiable simulators with neural networks.
                In <em>Proceedings of the IEEE International Conference on Robotics and Automation (ICRA)</em>, 2021.
                URL <a target="_blank"
                    href="https://github.com/google-research/tiny-differentiable-simulator">https://github.com/google-research/tiny-differentiable-simulator</a>.
            </li>
            <li>
                R. Featherstone. <em>Rigid Body Dynamics Algorithms</em>. Springer-Verlag, Berlin, Heidelberg, 2007.
                ISBN 0387743146.
            </li>
            <li>
                L. S. Pontryagin. <em>Mathematical theory of optimal processes</em>. Routledge, 2018.
            </li>
            <li>
                A. Asseman, T. Kornuta, and A. Ozcan. Learning beyond simulated physics. In <em>Modeling and
                    Decision-making in the Spatiotemporal Domain Workshop</em>, 2018.
                URL <a target="_blank"
                    href="https://openreview.net/forum?id=HylajWsRF7">https://openreview.net/forum?id=HylajWsRF7</a>.
            </li>
            <li>
                F. Ramos, R. Possas, and D. Fox. BayesSim: Adaptive domain randomization via probabilistic inference for
                robotics simulators.
                In <em>Proceedings of Robotics: Science and Systems</em>, Freiburg im Breisgau, Germany, June 2019.
                <a target="_blank" href="http://dx.doi.org/10.15607/RSS.2019.XV.029">doi:10.15607/RSS.2019.XV.029</a>.
            </li>
            <li>
                C. M. Bishop. Mixture density networks. 1994.
            </li>
            <li>
                P. Kidger and T. Lyons. Signatory: differentiable computations of the signature and logsignature
                transforms, on both CPU and GPU.
                In <em>International Conference on Learning Representations</em>, 2021.
                <a target="_blank"
                    href="https://github.com/patrick-kidger/signatory">https://github.com/patrick-kidger/signatory</a>.
            </li>
            <li>
                C. E. Rasmussen and C. K. I. Williams.
                <em>Gaussian Processes for Machine Learning (Adaptive Computation and Machine Learning)</em>.
                The MIT Press, 2005. ISBN 026218253X.
            </li>
            <li>
                T. Coleman David. Reducing the Barrier to Entry of Complex Robotic Software: a MoveIt! Case Study.
                2014. <a target="_blank"
                    href="http://dx.doi.org/10.6092/JOSER_2014_05_01_P3">doi:10.6092/JOSER_2014_05_01_P3</a>. URL
                <a target="_blank" href="https://aisberg.unibg.it//handle/10446/87657">
                    https://aisberg.unibg.it//handle/10446/87657</a>. Publisher: Universita degli studi di Bergamo.
            </li>
            <li>
                D. Q. Huynh. Metrics for 3d rotations: Comparison and analysis. <em>Journal of Mathematical Imaging and
                    Vision</em>, 35(2):155–164, 2009.
            </li>
        </ul>
    </div>

    <div class="container" id="acknowledgements">
        <h2>Acknowledgements</h2>

        <p class="lead">This work was supported by a Google PhD Fellowship and a NASA Space Technology
            Research
            Fellowship, grant number 80NSSC19K1182.</p>
        <p class="lead">G.S. Sukhatme holds concurrent appointments as a Professor at USC and as an Amazon
            Scholar. This
            paper describes work performed at USC and is not associated with Amazon.</p>
    </div>

    <div class="bg-light">
        <div class="container" align="right" style="padding:40px 0">
            Last updated on September 14, 2021
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf"
        crossorigin="anonymous"></script>
</body>

</html>